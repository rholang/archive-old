(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[87],{1028:function(n,e,t){"use strict";t.r(e);e["default"]={content:"# Church Numerals\n\nIn this implementation the natural numbers are represented by nested outputs.\n```javascript\n⟦0⟧( zero, succ ) = zero!( 0 )\n⟦n⟧( zero, succ ) = succ!( ⟦n - 1⟧( zero, succ ) )\n```\nThis allows for a relatively concise implementation of addition\n```javascript\n⟦m+n⟧( zero, succ ) = {\n    new zerom, zeron, succm, succn, rtn;\n    for( r <- rtn ) { *r }\n    | add( zerom, zeron, succm, succn, zero, succ, rtn )\n    | ⟦m⟧( zerom, succm ) | ⟦n⟧( zeron, succn )\n}\n```\nwhere we avail ourselves of the contracts copy and add below. The implementation illustrates the use of namespaces to isolate processes from each other. If the interpretation of m and n are realized in the same namespace, that is, using the same zero and succ channels, then processes operating on them have to worry about mixing and interaction between the processes representing those numbers. More precisely, a process that interacts with both\n```javascript\n ⟦m⟧( zero, succ ) and ⟦n⟧( zero, succ )\n```\nneeds to worry, potentially, about which process the communications on zero and succ originate from. If we have distinct names zerom, zeron, succm, succn, then we can effect an identification of the processes representing each number.\n```javascript\n ⟦m⟧( zerom, succm ) and ⟦n⟧( zeron, succn )\n```\nThat’s what the implementation of + does. It interprets each number into its own separate namespace, then it calls add which interacts with each process, pulling on each succi channel concurrently, until one or both of them reaches zeroi, copying the remainder from the source namespace into the result namespace, zero and succ, before piling on the succs from the original parameters to the interpretation of +, to at a time, account for the decrements of the simultaneous recursive descent.\n\n\n\n// copy moves a process representing a number in the namespace \n\n// defined by zero1 and succ1 into a namespace defined by zero2 and succ2\n\n```javascript\ncopy( zero1, succ1, zero2, succ2, rtn ) = {\n    select {\n        case mo <- succ1 => {\nnew rtp;\nfor( r <- rtp ) { rtn!( succ2!( *r ) ) }\n| copy( zero1, succ1,zero2,succ2,rtp ) | mo\n        }\n        case z <- zero1 => rtn!( zero2!( 0 ) )\n    }\n}\n```\n\n// add implements the arithmetic addition between numbers in different namespaces \n\n// placing the resulting process in the namespace zeromn, succmn, on the channel rslt\n\n```javascript\nadd( zerom, succm,  zeron, succn, zeromn, succmn, rslt ) = {\n   select {\n       case mmo <- succm; nmo <- succn => {  // both processes have more to say about succession\n          new rsltmt;\n             for( r <- rsltmt ){\n                rslt!( succmn!( succmn!( *r ) ) ) // we decremented by 2 in the join\n             }\n            | add( zerom, zeron, succm, succn, zeromn, succmn, rsltmt )\n            | *mmo | *nmo\n       }\n       case mmo <- succm; zn <- zeron => { // n has run out of things to say about succession, but not m \n            new rtn;\n            for( mmr <- rtn ) {\n                rslt!( succmn!( *rtn  ) )\n            }\n            | copy( zerom, succm, zeromn, succmn, rtn ) | *mmo\n       }\n       case nmo <- succn; zm <- zerom => {  // m has run out of things to say about succession, but not n            \n            new rtn;\n            for( nmr <- rtn ) {\n                rslt!( succmn!( *rtn  ) )\n            }\n            | copy( zeron, succn, zeromn, succmn, rtn ) | *nmo\n       }\n       case zm <- zerom; zn <- zeron => { // both processes have run out of things to say about succession\n            rslt!( zeromn!( 0 ) )\n       }\n}\n```\nOf course, this is not the only interpretation. There is a dual interpretation where successor is not realized as output, but as input. The reader is encouraged to investigate an implementation of this interpretation as it is equally instructive.\n",data:{title:"Church Numerals",description:"Everything you need to know to get up and running with Atlaskit"},isEmpty:false,excerpt:""}}}]);