(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[65],{1006:function(e,n,t){"use strict";t.r(n);n["default"]={content:'\n# State Channels \n\nBy now you\'re good at sending data to the tuplespace, and receiving data from the tuplespace. But whenever you\'re computing, you occasionally need to set data aside to be used later. Almost every programming language has a concept of variables.\n\n## Holding on to data\n\n![Variables are so 2015. It\'s all about state channels now.](./images/state-channels-variables.png)\n\n\n\nAnother way in which rholang is unique is that it doesn\'t have traditional variables. Instead, we can just use the tuplespace to store our data. Whenever you want to set something aside for later, just send it on some channel and receive it back later. Channels that are used in this way are called "state channels", and often have `Ch` at the end of their name\n\n```javascript\nnew stdout(`rho:io:stdout`), boxCh in {\n  // To save data we just put it in the box\n  boxCh!(42)\n  |\n\n  // Then to get data back out\n  for (data <- boxCh) {\n    // Do whatever you want with the data here.\n    stdout!(*data)\n  }\n}\n```\n\nWhat data gets sent to `@somePublicChannel`?\n- [ ] 0\n- [ ] box\n- [x] 42\n- [ ] It is empty\n\n\nWhat data is left in the `boxCh` state channel?\n- [ ] 0\n- [ ] @"somePublicBox"\n- [ ] 42\n- [x] It is empty\n\n\n## Persisting Data\nIf we were to check the box again, we would not get a result. Because once we receive the message, it gets consumed from the tuplespace. We briefly discussed the solution back in our lesson on persistent sends and peeks.\n\n```javascript\nnew boxCh in {\n  // To save data we just put it in the box\n  boxCh!(42)\n  |\n\n  // To check the value without consuming it\n  for (data <- boxCh) {\n    // We send a copy back to the box\n    boxCh!(*data)\n    |\n    // The do whatever with it\n    @"somePublicChannel"!(*data)\n  }\n}\n```\n\nWhat data gets sent to `@somePublicChannel`?\n- [ ] 0\n- [ ] box\n- [x] 42\n- [ ] It is empty\n\n\nWhat data is left in the `boxCh` state channel?\n- [ ] 0\n- [ ] @"somePublicBox"\n- [x] 42\n- [ ] It is empty\n\n\n## Patience Game Revisited\nA few lessons back we discussed the patience game, where each player hopes to be the last one to send a message to the contract. We had some problems back then because we couldn\'t guarantee that a result of the game would ever be output.\n\nTake a minute to remind yourself of the problem we had. With a state channel, we can solve this problem properly.\n\n```javascript\nnew P1, P2, stdout(`rho:io:stdout`) in {\n\n  // active gets its own scope so players can\'t change its value.\n  new active in {\n    active!(true)\n    |\n    for(_ <- active; _ <- P1) {\n      for( _ <- P2) {\n        stdout!("P2 Wins")\n      }\n    }\n    |\n    for(_ <- active; _ <- P2) {\n      for (_ <- P1) {\n        stdout!("P1 Wins")\n      }\n    }\n  }\n  |\n  P1!(Nil)\n  |\n  P2!(Nil)\n}\n```\n\nHow does the above code avoid the problem of each block getting called once?\n- [ ] By forcing player one to use the top block\n- [x] Because after the first call `activeCh` is empty\n- [ ] Because state channel make things sequential\n\n## Objects and Methods\n![This click-counter can be incremented and reset](./images/state-channels-clickCounter.png)\n\nIn "Object Oriented Programming" languages such as java, we can model real-world objects by encapsulating some data along with methods that use or change the data. The same thing is possible in rholang.\n\nIn this example, we\'ll create an object that represents a basic click counter. The ingredients are:\n* State Channels: currentCount\n* Methods: increase, reset\n\n```javascript\nnew currentCount, increase, reset, check, stdout(`rho:io:stdout`) in {\n  \n  // Starting the counter at 0\n  currentCount!(0) |\n\n  // Method to increase counter (returns the old value)\n  contract increase(ack) = {\n    for(old <- currentCount) {\n      currentCount!(*old + 1) |\n      ack!(*old)\n    }\n  } |\n\n  // Method to reset the counter (returns the old value)\n  contract reset(ack) = {\n    for(old <- currentCount) {\n      currentCount!(0) |\n      ack!(*old)\n    }\n\n  } |\n\n  // Increase the value three times\n  new ack in {\n    increase!(*ack) |\n    for(_ <- ack) {\n      increase!(*ack) |\n      for(_ <- ack) {\n        increase!(*ack) |\n        for(_ <- ack) {\n          increase!(*ack) |\n\n          // And check it\'s value afterwards\n          for(_ <- ack; count <- currentCount) {\n            stdout!(*count)\n          }\n        } \n      }\n    }\n  }\n}\n```\n\n### Exercises\nIt is inconvenient to manually replace the counter value each time I check it. Instead we should have a method for that.\n\n\x3c!-- answer in checkMethod.rho --\x3e\n\n\n### Exercise\nNow that it\'s easier and safer to check the counter, let\'s write some better tests that actually check all the methods.\n\n\x3c!-- answer in counterTests.rho --\x3e\n\n## Factories\nIf you\'ve programmed in other languages like java you may be familiar with constructors. If you haven\'t programmed in in java, that\'s great, because Rholang uses factories to make new objects rather than constructors.\n\nThe counter is a useful construct in rholang, and you\'ll likely find that you use it in your projects. The problem is that many projects may want to use counters, and having just one is insufficient. So the solution is to make a factory contract that makes counters. When the factory contract is called, it sends back a brand new counter.\n\n```javascript\nnew counterFactory, stdout(`rho:io:stdout`) in {\n  contract counterFactory(increase, reset) = {\n    new currentCount in {\n      // Start the counter at zero\n      currentCount!(0) |\n\n      // Method to increase counter (returns the old value)\n      contract increase(ack) = {\n        for (old <- currentCount) {\n          currentCount!(*old + 1) |\n          ack!(*old)\n        }\n      }\n      |\n\n      // Method to reset the counter (returns the old value)\n      contract reset(ack) = {\n        for(old <- currentCount){\n          currentCount!(0) |\n          ack!(*old)\n        }\n      }\n    }\n  }\n  |\n\n  new ack, myIncrease, myReset in {\n    // Demo using the counter here\n    Nil\n  }\n}\n```\n\nHow would a user call the factory to get a new counter?\n- [ ] `counterFactory!(*ack)`\n- [ ] `counterFactory!(0, *ack)`\n- [ ] `@"counterFactory"()`\n- [x] `counterFactory!(myIncrease, myReset)`\n\nHow would a user reset their counter after creating as indicated above.\n- [ ] `myIncrease!(*ack)`\n- [x] `myReset!(*ack)`\n- [ ] `counterFactory!(myReset, *ack)`\n- [ ] `counterFactory!(myReset)`\n\n\n\n## Method Dispatching\nThere are two primary techniques for making methods available. The first option I call "separation of powers" because each method listens on its own dedicated channel.\n\nAnother option is the "control panel" technique where there is a single unforgeable name called the control panel and all the methods are built on it.\n\n```javascript\n// Separation of Powers\ncontract factory(method1, method2) = {\n  contract method1(ack) = { ... }\n  contract method2(ack) = { ... }\n}\n\n// Control Panel\ncontract factory(cPanel) = {\n  contract @[cPanel, "method1"](ack) = { ... }\n  contract @[cPanel, "method2"](ack) = { ... }\n}\n```\n\nWhich technique did the counter example use to dispatch methods?\n- [x] Separation of Powers\n- [ ] Control Panel\n\n### Exercise\nConvert the counter example to use the other method dispatching technique. You should convert the tests too.\n',data:{title:"State Channels",description:"Everything you need to know to get up and running with Atlaskit"},isEmpty:false,excerpt:""}}}]);