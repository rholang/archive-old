(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[63],{1004:function(e,n,t){"use strict";t.r(n);n["default"]={content:'# Bundles Interpolation\n\n## Stolen Messages\n\n![Alice\'s fans love her and want to send her lots of mail .](./images/bundles-Alice.png)\n\nAlice is a rising celebrity who receives mail from her fans. They used to send mail directly to her.\n\n```javascript\nnew alice, stdout(`rho:io:stdout`) in {\n  // Alice reads fan mail\n  for (mail <- alice) {\n    stdout!("Alice received a fanmail")\n  }\n  |\n\n  // Bob sends fan mail\n  alice!("Dear Alice, you\'re #TheBest")\n}\n```\n\nBut as she became more popular, her jealous competitor Eve began stealing her mail. (Imagine that Eve can run code inside the first set of curly braces.)\n\n### Exercise\nWrite the code for a competitor to steal the mail  \x3c!-- Answer in fanmailEve.rho --\x3e\n\nThe problem is that the competitors can listen on the same channel Alice can. So what she really needs is for her fans to have a "write-only bundle"\n\n```javascript\nnew alice, bob, eve, stdout(`rho:io:stdout`) in {\n  // Alice gets a lot of fan mail, so she\n  // creates a new write only bundle and publishes it.\n  new aliceFanMail in {\n\n    // Alice gives fanmail channel publicly\n    alice!!(bundle+ {*aliceFanMail})\n    |\n\n    // Alice also reads fan mail\n    for (mail <= aliceFanMail) {\n      stdout!("Alice received a fanmail")\n    }\n  }\n  |\n\n  // When Bob wants to send fanmail he asks for the channel\n  // and then sends\n  for (aliceFanMail <- alice) {\n    aliceFanMail!("Dear Alice, you\'re #TheBest")\n  }\n  |\n\n  // Eve tries to intercept a message, but cannot\n  // because Alice\'s fanmail channel is write-only\n  for (aliceFanMail <- alice) {\n    for (@stolenMail <= aliceFanMail) {\n      stdout!(["Eve stole a message: ", stolenMail])\n    }\n  }\n}\n```\n\nThe `bundle+ {*aliceFanMail}` is a channel just like `aliceFanMail` except it can only be sent on, not received.\n\n## Subscriptions\nThe bundle solution above does prevent Eve from stealing mail, which is good. But in the blockchain context it also has the unfortunate side effect that Alice has to pay to send her fanmail address. Blockchain fees work a little like postage.\n\n![The sender includes a return envelope already posted to himself](./images/bundles-returnEnvelope.png)\n\n### Exercise\n\nAlice can save postage by making fans request the fanmail address from her. Then they will have to pay the transaction costs. A bit like sending a return envelope with a stamp already on it.\n\nComplete Alice\'s code so that she can get Bob the address he needs.\n\nHere\'s the answer:\n```javascript\nnew alice, bob, eve, stdout(`rho:io:stdout`) in {\n\n  // Alice get a lot of fan mail, so she\n  // creates a new write only bundle and publishes it.\n  new aliceFanMail in {\n\n    // Alice returns fanmail channel to any fan that asks\n    for (return <= alice) {\n      return!(bundle+ {*aliceFanMail})\n    }\n    |\n\n    // Alice also reads fan mail\n    for (mail <- aliceFanMail) {\n      stdout!("Alice received a fanmail")\n    }\n  }\n  |\n\n  // When Bob wants to send fanmail he asks for the channel\n  // and then sends\n  new return in {\n    alice!(*return) |\n    for (aliceFanMail <- return) {\n      aliceFanMail!("Dear Alice, you\'re #TheBest")\n    }\n  }\n  |\n\n  // Eve tries to intercept a message, but cannot\n  // because Alice\'s channel is write-only\n  new return in {\n    alice!(*return) |\n    for (aliceFanMail <- return) {\n      for (@stolenMail <= aliceFanMail) {\n        stdout!(["Eve stole a message: ", stolenMail])\n      }\n    }\n  }\n}\n```\n\n\nAstute readers will notice that Eve can now just intercept messages asking for the fanmail address. Good observation. As a bonus exercise, you could write Eve\'s new code. (hint: it\'s the same as the old code). The solution to this problem involves public key cryptography and the registry. We\'ll learn about that later on.\n\n### Exercise\nOur pizza shop back in lesson 2 had a similar problem to Alice. Rework that code so they can easily take on new customers.\n\n## Jackpot\n\n![A single "thrower" throws a ball for one of many catchers to catch](./images/bundles-jackpot.png)\n\nI used to play a game called jackpot as a kid. One player would throw the ball and yell a number. The other players would all try to catch the ball and whoever caught it would receive that number of points.\n\nPlaying jackpot is just the opposite of sending fanmail. Before there were many fans all sending to one celebrity. Now there is one thrower, sending to one of many recipients\n\n```javascript\nnew throw, stdout(`rho:io:stdout`) in {\n  // Throw the ball worth five points\n  throw!(5)\n  |\n\n  // Throw the ball several more times\n  throw!(4) |\n  throw!(2) |\n  throw!(6) |\n\n  // Bill and Paige both try to catch\n  for (points <= throw){\n    stdout!("Bill caught it")\n  }\n  |\n  for (points <= throw){\n    stdout!("Paige caught it")\n  }\n}\n```\n\nWho will catch the ball in the jackpot code?\n- [ ] Bill because his catch code is first.\n- [ ] Bill because his catch code is closest to the throw code.\n- [ ] Paige because her catch code is last.\n- [x] We don\'t know; it is nondeterminate.\n\n\n### Exercise\nExercise: Use stdoutAck to display how many points each person actually gets when they catch the ball.\n\x3c!-- solution in jackpotNicePrinting.rho --\x3e\n\n\n\nHow is this game in rholang different than the real game where one ball is thrown repeatedly?\n- [ ] It is a very accurate simulation\n- [x] In rholang all balls are thrown concurrently and caught in any order\n- [ ] In rholang the balls are caught in the reverse order from what they are thrown.\n- [ ] In rholang Bill makes all his catches, then Paige makes all her catches.\n\n\n## Side Bar: String Operations\nMost programming languages will allow you to join or "concatenate" two strings together, and rholang is no exception. We can `stdout!("Hello " ++ "world")`, but we can\'t concatenate a string with an int.\n\nOne solution is to use `stdoutAck` andsend acknowledgements. Another option is to print a list  `stdout!(["Bill caught it. Points earned: ", *points])`. We\'ll go into more detail about both techniques in future lessons.\n\nA final option is to use string interpolation. String interpolation allows you to put placeholders into your strings and replace them with actual values using a map.\n\n```javascript\nnew stdout(`rho:io:stdout`) in {\n\n  printStuff!({"noun": person, "adverb": sideways}) |\n  \n  contract printStuff(map) = {\n    stdout!("The ${noun} jumped ${adverb}" %% *map)\n  }\n}\n```\n\nYou can learn more about how the map that gets sets in lesson 12 on data structures.\n\n## Imposter throws\n\nNotice that anyone can come along and mess up this game by throwing fake balls. This is just the opposite of Eve coming along and stealing Alice\'s fanmail.\n\nWhat code would Eve have to par in to throw an imposter ball worth 100 points?\n- [ ] for (imposter <- throw){imposter!(100)}\n- [x] throw!(100)\n- [ ] @"throw"!("100")\n\n\nWe solve this problem by making sure that the public can only read from the throw channel, but not write to it.\n\n```javascript\nnew gameCh, stdout(`rho:io:stdout`) in {\n  new throw in {\n\n    //Give out read-only access\n    gameCh!!(bundle- {*throw})\n    |\n    // Now actually make all the throws\n    throw!(4) |\n    throw!(2) |\n    throw!(6)\n  }\n  |\n  // Bill and Paige join the game\n  for (throw <- gameCh){\n    for (points <= throw){\n      stdout!(["Bill caught it. Points: ", *points])\n    }\n  }\n  |\n  // Eve tries to throw a fake, but can\'t\n  for (throw <- gameCh){\n    throw!(100)\n  }\n}\n```\n\nLike before, this code requires the game host to pay for everyone who get\'s the bundle from him. It could be refactored so players have to subscribe to the game like we did with Alice and her fan mail.\n\n## Public Key Crypto\n\n![private names](./images/bundles-privateNames.png)\n\n\nIn some ways, read-only bundles duplicate the signing features of [public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography). The jackpot catchers here are sure that the balls came from the thrower because only he can send on the throw channel, which is a lot like cryptographic signing.\n\nIn some ways write-only bundles duplicate the encryption features of public-key cryptography. Only Alice can receive messages sent on her fan mail channel. One **very important difference** is that the messages sent here are 100% visible from outside the blockchain! So while write-only bundles are an effective way to communicate unforgeable names, they are not a good way to plot a heist, or evade government surveillance. **Be Careful!**\n\n## More About Bundles\n\nIn addition to read- and write-only bundles, there are two other types that are also useful.\n\n| Syntax | Can Read | Can Write |\n| ------ | -------- | --------- |\n| `bundle- {proc}`  | YES |  NO |\n| `bundle+ {proc}`  | NO  | YES |\n| `bundle0 {proc}`   | NO  |  NO |\n| `bundle {proc}`   | YES | YES |\n\nYou may be wondering why a bundle on which you can neither send nor receive would ever be useful. Given what we\'ve learned so far, that\'s a wonderful question. When we discuss pattern matching next unit, we\'ll see that bundles do more than restrict read- and write- capabilities. They also prevent taking compound names apart to look inside.\n',data:{title:"Bundles Interpolation",description:"Everything you need to know to get up and running with Atlaskit"},isEmpty:false,excerpt:""}}}]);