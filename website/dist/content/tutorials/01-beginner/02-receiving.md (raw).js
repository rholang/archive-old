(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[54],{995:function(e,n){e.exports='---\ntitle: Receiving \ndescription: Everything you need to know to get up and running with Atlaskit\n---\n# Receiving \n\nWe learned last time how to send a message. Now it\'s time to learn how to receive a message.\n## Check for Messages\n\n![// Dear future self, keys in freezer because...](./images/receiving-Keys.png)\n\nThe general syntax is:\n\n```javascript\nfor(message <- channel){\n  // Do something here\n}\n```\n\nWhen some message show up on `channel` it gets received and is referred to as `message`. The code inside the curly braces, `{}`, is called a "continuation" and it runs when a message is received.\n\nBTW, lines that start with `//` are called comments. They\'re just there for human coders and don\'t affect the way the program runs at all. They\'re a good idea, and you should use them! Anyone who reads your code will appreciate them (including your future self).\n\n\n## Comm Events\n\n![Pizza shop can receive messages on its channel.](./images/receiving-pizza.png)\n\nThe following code sends a message on a channel for a pizza shop and the pizza shop receives it. The pizza shop acknowledges receiving the message by printing to `stdout`.\n\nnew pizzaShop, stdout(`rho:io:stdout`) in {\n  pizzaShop!("2 medium pies")\n  |\n  for(order <- pizzaShop){\n    stdout!("Order Received.")\n  }\n}\n\n\n### Exercise\nSend that message to a different channel like `coffeShop`. Did the acknowledgement print? Is anything left in the tuplespace?\n\n![Let\'s hit up the coffee shop.](./images/receiving-coffee.png)\n\n### Exercise\nRemember, in rholang things don\'t happen in any particular order, they happen concurrently. The pizza shop code will work just as well if we put the receive first. Give it a try!\n\n\n## Receiving Before Sending\n\n![Rather than the message appearing first, then someone receiving it, Bob is trying to receive first. Hopefully someone will send him a message so he can have a comm event.](./images/receiving-lookingForMessages.png)\n\nWhen a send and a receive come together on a channel, it is called a communication event, or "comm event" for short.\n\nUnlike normal mail where a message must be sent _then_ received, the two can happen in either order or at the same time in rholang. It is just as acceptable to receive a message, then send it. Whenever a send and receive come together, a comm event takes place.\n\n\n## Contracts\n\n![The poor chef is too busy making sure he can receive orders to take care of his pizza.](./images/receiving-pizzaBurning.png)\n\nOur pizza shop example illustrates comm events nicely, but it isn\'t very realistic to expect the pizza shop to manually issue a new receive every time an incoming order consumes theirs from the tuplespace.\n\nLuckily it\'s possible to deploy code once, and have it run _every_ time it receives a message. This kind of thing is called a "smart contract". Let\'s look at some code for a coffee shop that is much superior to the pizza shop.\n\n```javascript\nnew coffeeShop, stdout(`rho:io:stdout`) in {\n  contract coffeeShop(order) = {\n    stdout!("Coffee Order Received")\n  }\n  |\n  coffeeShop!("one hot chocolate")\n  |\n  coffeeShop!("two large cappuccinos please")\n}\n```\n\n### Exercise\nOrder more drinks from the coffee shop\n\n### Exercise\nChange the acknowledgement message that the coffee shop prints when it receives an order.\n\nWhich should generally come first?\n- [ ] A send because that\'s how normal mail works.\n- [ ] A receive because it\'s faster to run the code that way.\n- [x] Either a send or a receive can come first, or they can come together.\n- [ ] A receive because rholang is concurrent.\n- [ ] Neither. Just make a comm event directly.\n\n### Exercise\nThe channel is just named `coffeeShop`. Change it to be named after a specific coffee shop of your choosing.\n\n\n## Persistent For\nThere are actually two different styles of syntax in rholang to achieve this persistent behavior. We just learned about `contract`, the other looks much more like a regular receive. The following snippets are equivalent.\n\n```javascript\ncontract coffeeShop(order) = {\n```\n\n```javascript\nfor(order <= coffeeShop) {\n```\nNotice this is different from a normal `for` because it has a double arrow `<=` rather than a single arrow `<-`. The only difference between the persistent for and a contract comes when we start talking about blockchains. For now you can think of them as the same thing.\n\n### Exercise\nThe pizza shop could use a contract like the one the coffee shop had. Let\'s write it one but use a persistent for instead of a contract. Try to write the entire thing from scratch so you remember the syntax better.\n\n```javascript\nnew pizzaShop, stdout(`rho:io:stdout`) in {\n  for (order <= pizzaShop) {\n    stdout!("Pizza Order Received")\n  }\n  |\n  pizzaShop!("one hot chocolate")\n  |\n  pizzaShop!("two large latte\'s please")\n}\n```\n\n\nWhich of these things is not like the other?\n- [x] `for (a <- b){}`\n- [ ] `contract b(a) = {}`\n- [ ] `for (a <= b){}`\n\nWhich send will produce a comm event with `for (message <- grandmasSnapChat){Nil}`?\n- [ ] `for(grandmasSnapChat)!("Hi Grandma")`\n- [x] `grandmasSnapChat!("Glad you\'re snapping Grandma")`\n- [ ] `for("Here\'s a snap for you g\'ma" <- grandmasSnapChat)`\n'}}]);