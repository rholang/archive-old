(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[56],{997:function(e,n){e.exports='---\ntitle: Names and Processes\ndescription: Everything you need to know to get up and running with Atlaskit\n---\n# Names and Processes\n\nWe\'ve previously learned how to send a message to grandma or a pizza shop. But so far all those recipients have done is acknowledge the message by printing to standard output.\n\n## Message Relaying\n\nNow let\'s make them do something more interesting by passing the message along like in a child\'s telephone game\n\n![The game of telephone is perfect to simulate message forwarding in rholang.](./images/names-telephone.png)\n\n\n```javascript\nnew alice, bob, stdout(`rho:io:stdout`) in {\n  // Start the game by sending a message to Alice\n  alice!("How to program: Change stuff and see what happens.")\n  |\n\n  // Concurrently, Alice listens for the message\n  for (message <- alice) {\n\n    // When she receives the message she\'ll pass it on to Bob\n    bob!(*message)\n  }\n  |\n\n  // Concurrently, Bob will listens for the message\n  for (message <- bob) {\n    // Bob is the last player, so he\'ll announce the message\n    stdout!(*message)\n  }\n}\n```\n\nAs the message says, you learn most when you experiment. So be sure to change things as you see fit.\n\n### Exercise\n\nThat telephone game was fun, but it\'s always better the have more players. Go ahead and add a third player called Charlie. Instead of printing to `stdout`, bob will send the message along to Charlie. Then Charlie will print it to the screen. The More the Merrier!\n\n\n\n![The message never seems to get there correctly. I blame Bob.](./images/names-telephoneChangedMessage.png)\n\n\n\n### Exercise\nIf you\'ve ever actually played telephone, you know that the message rarely arrives in tact. Change the program so Bob passes along a different message regardless of what he receives.\n\n\n## WTH is That `*`?\n\n![Opposites attract](./images/names-inverse.png)\n\nDid you notice the `*` in `bob!(*message)`? In rholang there are two kinds of things, "channels" and "processes". There are also ways to convert between the two.\n\n\x3c!-- TODO: Maybe an illustration of arrows labeled * and @ would be better here? --\x3e\n\nA "process" is any piece of rholang code such as our telephone game, or our pizza shop order program. Processes can be big hundred-line programs or small on-liners. They can even be tiny pieces of code that are just values.  Here are some example processes.\n\n - `stdout!("Sup Rholang?")` A common send\n - `Nil` The smallest possible process. It literally means "do nothing".\n - `for(msg <- phone){Nil}` A common receive that does nothing when a message arrives.\n - `"Hello World"` Another small process that also does nothing. These are called "Ground Terms".\n\n\nA channel (also frequently called a "name") is something that can be to send messages over. In rholang, names come from "quoting processes" by putting the `@` sign before a process. Here are some example names.\n\n - `@"Hello World"` Made by quoting the ground term "Hello World".\n - `@Nil` The smallest possible name. Made by quoting the smallest possible process.\n - `@(alice!("I like rholang, pass it on."))` Made by quoting a process from our telephone game\n\n## So What is `*` all about?\n\n![What kind of name is that!? Did your parents just name you after some computer code?](./images/names-myNameIs.png)\n\nWe can package processes up to make names by quoting them with the `@` symbol. We can also turn names back into processes by "unquoting" them with the `*` symbol.\n\nThe big thing to remember is in rholang we **send processes and receive names**. That\'s important so I\'ll say it again. You always **send a process** and on the other end, you **receive a name**.\n\nWhen Alice receives our message with `for(message <- alice)` she is receiving, so `message` becomes a name. When she later sends to Bob she has to send a process, so she uses `*` to turn `message` back into a process with `bob!(*message)`\n\n\n\n## Quiz\n\nWhat do we send?\n- [x] processes\n- [ ] names\n\n\n\nWhat do we receive?\n- [ ] processes\n- [x] names\n\n\n\n  What is `registration` from the code `new registration in {...}`\n- [ ] process\n- [x] name\n- [ ] invalid syntax\n\n\n\n\nWhat is `Nil`?\n- [x] process\n- [ ] name\n- [ ] invalid syntax\n\n\n\nWhat is `@Nil`?\n- [ ] process\n- [x] name\n- [ ] invalid syntax\n\n\n\n\nWhat is `@@Nil`?\n- [ ] process\n- [ ] name\n- [x] invalid syntax\n\n\n\n`*importantData` is a process, so what is `importantData`?\n- [ ] process\n- [x] name\n- [ ] invalid syntax\n\n\n\n  Which of these is equivalent to `"BobsPhone"`?\n- [x] `*@"BobsPhone"`\n- [ ] `@"BobsPhone"`\n- [ ] `*"BobsPhone"`\n- [ ] `@*"BobsPhone"`\n- [ ] `stdout!("BobsPhone")`\n\n\n\n### Exercise\n\n![telefone](./images/names-telephoneFork.png)\n\n\nInstead of a linear telephone game where each player passes the message to the next, let\'s add a branch in the game. So now Bob will send to Charlie like before, but Bob will also send to Dawn.\n\nEach branch can be as long as you want, but at the end of each branch, print the message to `stdout`.\n'}}]);