(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[69],{1029:function(e,n,t){"use strict";t.r(n);n["default"]={content:'\n# Object Capabilities\n\nRecently we learned how unforgeable names can restrict the use of a channel to those who know the name. We\'ve also see how state channels can be used to store data and methods can be used to modify encapsulated data. In this lesson we\'ll see how methods that are placed on unforgeable names lead to a tremendously useful design pattern known as "object capabilities".\n\nAn everyday example of an object capability is the key to your home or car. Possessing the object gives you the capability to enter the home or start the car. With object you also have the ability to delegate by giving to key or a copy of the key to someone else.\n\nIn this lesson we\'ll build up a few example projects that uses state channels, and object capabilities. We\'ll see that object capabilities can be used more generally than bundles to grant permissions such as reading and writing data, but also more abstract capabilities like reseting a counter or deleting a facebook account.\n\n## ATC Revisited\nLet\'s revisit the air traffic control example from lesson 4. Previously controllers were able to broadcast weather and runway information by using a repeated send. But they were not able to update the information. And we all know weather can change unpredictably. So in this example we\'ll store the current information on a state channel, and give the controllers a capability to update it as necessary.\n\n```javascript\nnew stationFactory, stdout(`rho:io:stdout`) in {\n  contract stationFactory(initialMessage, getInfo, setInfo) = {\n    new currentMessage in {\n      // Populate the initial message\n      currentMessage!(*initialMessage)\n      |\n\n      // Owner can update the message anytime\n      contract setInfo(newMessage) = {\n        for (msg <- currentMessage) {\n          currentMessage!(*newMessage)\n        }\n      }\n      |\n\n      // User tunes in for latest message\n      contract getInfo(return) = {\n        for (msg <- currentMessage){\n          return!(*msg)\n          |\n          currentMessage!(*msg)\n        }\n      }\n    }\n  }\n  |\n\n  // Controllers create new station with private set capability\n  // and public get capability\n  new airportInfo, set in {\n    stationFactory!("Weather is nice", *airportInfo, *set)\n  }\n  |\n  // Listener tunes in to receive latest message\n  airportInfo!(*stdout)\n}\n```\n\nIt may seem natural to use a read-only bundle for tuning into the station. However, if we use a bundle, then the first listener to receive the message, would consume it from the state channel. It wouldn\'t be left for other pilots to receive. In order to ensure that the message is persisted like we want, we handle all access to the state channel ourselves, and only give the pilots a capability to query for the the correct message.\n\nHow would the ATCs update the information?\n- [x] `set!("Strong crosswinds, be advised")`\n- [ ] `setInfo!("Strong crosswinds, be advised")`\n- [ ] `getInfo!("Strong crosswinds, be advised")`\n- [ ] `stationFactory.setInfo!("Strong crosswinds, be advised")`\n\n### Exercise\nWrite more thorough tests to make sure the ATCs can update the status successfully, and that pilots cannot\n\n## Savings Account\nIn this example we\'ll write code to model a simple savings account in rholang. It will have deposit, withdraw, and check methods.\n\nUnlike with our counter, a savings account needs to be secure. We don\'t want just anyone knowing our balance, or worse, withdrawing it.\n\nHere is some starter code to consider\n\n```javascript\nnew openAccount in {\n  // This contract registers a new account and creates its methods.\n  contract openAccount(initialDeposit, deposit, withdraw, check) = {\n    new balanceCh in {\n      balanceCh!(*initialDeposit)\n      |\n\n      // Withdraw Contract\n      contract withdraw(amount, ack) = {\n        for (old <- balanceCh) {\n          balanceCh!(*old - *amount) |\n          ack!(Nil)\n        }\n      }\n\n      // Deposit Contract\n\n      // Check contract\n    }\n  }\n  |\n\n  // Customer Sarah creates an uses an account\n  new sarahDeposit, sarahWithdraw, sarahCheck, ack in {\n    openAccount!(10, *sarahDeposit, *sarahWithdraw, *sarahCheck) |\n    sarahWithdraw!(3, *ack) |\n    for (_ <- ack) {\n      Nil// TODO check balance here\n    }\n  }\n}\n```\n\n### Exercise\nFill in the remaining methods in the account.\n\nWhich contract serves as a factory?\n- [ ] `check`\n- [ ] `withdraw`\n- [ ] `deposit`\n- [x] `openAccount`\n\nOur current savings account allows negative balances, but probably it shouldn\'t. Think about how you might try to solve that issue. We\'ll learn the proper tool to do that in our next lesson.\n\n## Stealing Funds\nTry to write the code Eve would need to par in to steal Sarah\'s funds. I bet you can\'t think of any. That\'s because only Sarah has access to the unforgeable names that control the account.\n\n\nIf Sarah wanted to allow her friend Stephanie to deposit into her bank account, but not check or withdraw, what code should she run?\n- [ ] `stephanie!(*sarahWithdraw)`\n- [x] `stephanie!(*sarahDeposit)`\n- [ ] `sarahWithdraw!("enable", *stephanie)`\n- [ ] `openAccount!(10, *sarahDeposit, @"sarahWithdraw", @"sarahCheck")`\n\n\n## Two Kinds of Factories\nSo far all of our factory methods have required us to pass in names on which to build the contracts. In the savings account example, those names were `check`, `deposit`, and `withdraw`. I call this a "BYOC" or "bring your own channel" factory. The BYOC technique has the advantage that the user can supply any names she likes including names she got from other contracts or public names.\n\nAnother technique is to allow the factory to create the necessary unforgeable names and send them back to the caller. I call this the a "full service" factory. If you don\'t require the flexibility of passing in arbitrary names, a full service factory is often less hassle.\n\n### Exercise\nConvert the savings account from byoc factory to to full service factory.\n\nNow that you\'ve converted the savings account, is it still possible for Sarah to make her deposit capability public?\n- [ ] No; she can no longer pass in a public name\n- [ ] No; she doesn\'t have access to do so\n- [x] Yes; she just needs to make the new capability public herself\n- [ ] Yes; just like before\n\n\n## Abortable Rocket Launch\nBack when we first learned the join operator we considered a scenario in which two operators must both give clearance to launch a rocket. We desired that they should also be able to retract the clearance.\n\nThis problem can be solved by giving the operator an abort button when they give their launch command.\n\n```javascript\nnew rocketFactory in {\n\n  // When a new rocket is setup, a launch capability for each for each operator is passed in\n  contract rocketFactory(aliceLaunch, bobLaunch, ack) = {\n    new aliceReadyCh, bobReadyCh in {\n      // Start out neither ready\n      aliceReadyCh!(false)|\n      bobReadyCh!(false)|\n\n      contract aliceLaunch(ack) = {\n        new aliceAbort in {\n          for (_ <- aliceReadyCh) {\n            aliceReadyCh!(true)\n          }\n          |\n          contract aliceAbort(ack) = {\n            for(_ <- aliceReadyCh) {\n              aliceReadyCh!(false)\n              |\n              ack!(Nil)\n            }\n          }\n          |\n          ack!(*aliceAbort)\n        }\n      }\n      |\n      Nil // Bob contract goes here\n      | ack!(Nil)\n    }\n  }\n  |\n  // Make a new rocket to test\n  new aliceLaunch, bobLaunch, ack in {\n    rocketFactory!(*aliceLaunch, *bobLaunch, *ack)|\n    for (_ <- ack){\n      Nil // Tests go here\n    }\n  }\n}\n```\n\n### Exercise\nComplete the above code with bob\'s launch logic and integration tests.\n\n## Design Patterns\nThere are many common Object Capability design patterns. Many of the are explained and illustrated in [A Picturebook of Secure Cooperation](http://erights.org/talks/efun/SecurityPictureBook.pdf)\n\n### Exercise\nWe will encounter many of these patterns as we work through the upcoming examples, but I encourage you to implement one or two of them in rholang right now.\n',data:{title:"Object Capabilities",description:"Everything you need to know to get up and running with Atlaskit"},isEmpty:false,excerpt:""}}}]);