(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[57],{998:function(n,e,t){"use strict";t.r(e);e["default"]={content:'# Send and Peek\n\n## Why send repeatedly?\n \n![This radio navigation aid helps airplanes navigate by broadcasting the same message over and over](./images/send-peek-broadcasting.png)\n\nOur pizza and coffee shops were both interested in receiving many messages on the same reusable channel. We accomplished that with a persistent for `for (msg <= chan){...}` or a contract `contract chan(msg){...}`.\n\nAn air traffic control tower may be interested in doing just the opposite -- sending the same message over and over. The controllers in the tower want to record a message containing weather and active runway information once, and make it available for every pilot who needs it. Like the pizza shop, they are busy and can\'t be bothered to continually re-send the message every time a pilot consumes it.\n\n\n\n## Persistent send syntax\n\nThe control tower just needs a minor adjustment in their code to make the send persistent. Rather than sending with a single `!`, they will use a double `!!`.\n\n```javascript\nnew airportInfo, stdout(`rho:io:stdout`) in {\n  // ATC sends the info\n  airportInfo!!("No wind; Runway 11")\n  |\n  // Pilot receives the info\n  for (info <- airportInfo) {\n    stdout!(*info)\n  }\n}\n```\n\nConfirm for yourself that the original send is still in the tuplespace.\n\n### Exercise\nModify the above code so that a second pilot also receives the information. Still, the send persists.\n\nBy the way, did you notice that we don\'t need `new stdout(...) in {}` when we don\'t actually print anything to the screen `stdout`?\n\nHow many comm events happen in `for (x <- y) {Nil} | y!!(Nil)`\n- [x] `1`\n- [ ] `many`\n- [ ] `0`\n\n\n## Double Checking a Message\n\nPersistent sends and receives are very useful as we just showed. But often normal sends and receives are perfectly good too. Imagine that the air traffic controllers want to update the airport information when the weather changes. If they use a persistent send, they cannot make updates.\n\nA better solution is to use a normal send and require each pilot who receives the message to put it back on the channel when they are done.\n\n```javascript\nnew airportInfo, stdout(`rho:io:stdout`) in {\n  // ATC sends the info\n  airportInfo!("No wind; Runway 11")\n  |\n\n  // Pilot receives the info\n  for (info <- airportInfo) {\n    stdout!(*info)\n    // TODO Pilot MUST put the info back\n  }\n  |\n\n  // ATC later records a new message\n  for (oldInfo <- airportInfo) {\n    airportInfo!("Wind 3 knots; Runway 11")\n  }\n}\n```\n\n### Exercise\nUsing what you already know, you can you can complete the code for an honest pilot to return the info to the `airportInfo` channel.\n\nGive that a try on your own first. The solution is listed below.\n\n\nHow many comms happen in `for (x <= y) {Nil} | y!!(Nil)`\n- [ ] `1`\n- [x] `many`\n- [ ] `0`\n\n\n\n## Peek Syntax\nOne problem with the code above is that a forgetful pilot may not actually put the information back on the `airportInfo` channel causing problems for other pilots who need it. A better solution would be to not actually _receive_ the message off of the channel in the first place.\n\n![Peeking at a message allows you to read it without consuming it.](./images/send-peek-letterPeek.png)\n\nTo "peek" at what\'s on a channel without consuming it, use the `<<-` operator.\n\n```javascript\nnew airportInfo, stdout(`rho:io:stdout`) in {\n  // ATC sends the info\n  airportInfo!("No wind; Runway 11")\n  |\n\n  // Pilot receives the info\n  for (info <<- airportInfo) {\n    stdout!(*info)\n  }\n  |\n\n  // ATC later records a new message\n  for (oldInfo <- airportInfo) {\n    airportInfo!("Wind 3 knots; Runway 11")\n  }\n}\n```\n\n\nWhich syntax is used to peek at a message?\n- [x] `for (x <<- y){...}`\n- [ ] `for (x <= y){...}`\n- [ ] `x!!(y)`\n\n\n\nHow many comms happen in `for (x <! y) {Nil} | y!!(Nil)`\n- [x] `1`\n- [ ] `many`\n- [ ] `0`\n\n## Security warning\nWe\'ve solved the problem of forgetful pilots removing the message and forgeting to put it back by teaching them to use peek instead. But this still doesn\'t solve the problem of malicios pilots intentionally taking the data. In reality we need to _enforce_ that nobody can leave `airportInfo` blank. We\'ll see how to do that in lesson 6.\n',data:{title:"Send and Peek",description:"Everything you need to know to get up and running with Atlaskit"},isEmpty:false,excerpt:""}}}]);