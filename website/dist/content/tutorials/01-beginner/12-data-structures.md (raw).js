(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[74],{1015:function(t,n){t.exports='---\ntitle: Data Structures\ndescription: Everything you need to know to get up and running with Atlaskit\n---\n# Data Structures\nIt is common for programs to process and store real world data. And whenever you have lots of data it is important to keep it organized so you can find the information you need quickly. In the analog world, paper files are kept organized by stacking them, putting them in folders, and file cabinets. The same concept applies in programming, and rholang is no exception (for once!).\n\n## String Methods\nLet\'s start with a familiar idea. We\'ve seen strings since the very first program in lesson one. Really strings are just a nice way to organize a bunch of characters, and that makes them a data structure. Like all data structures, strings have "methods" that you can perform on them.\n\nString\'s length method tells how many characters are in a string. While it\'s slice method creates a new string with some characters sliced off of each end. Strings also support the `++` operator for concatenation.\n\n```javascript\nnew wordLength, stdout(`rho:io:stdout`) in {\n  contract wordLength(@word) = {\n    stdout!("How many characters in " ++ word)|\n    stdout!(word.length())|\n    stdout!("Shorter version: " ++ word.slice(0, 5))\n  }\n  |\n  wordLength!("Cantaloupe")\n}\n```\n\nWhat is the result of `"hello world".length()`?\n- [ ] 2\n- [ ] 10\n- [x] 11\n- [ ] undefined\n- [ ] "hello"\n\nWhich of the following evaluates to "ello"?\n- [x] `"hello world".slice(1, 5)`\n- [ ] `"hello world".slice(0, 5)`\n- [ ] `"hello world".slice(1, 4)`\n- [ ] `"hello world".slice(3, 6)`\n\nStrings also have a method called `hexToBytes` that is designed to work on strings that contain valid hexadecimal numbers. It gives back a byte array that is represented by that hex number. Try to run `"1241243e".hexToBytes()`\n\n\nPro tip: It is also possible to slice a byte array. Experiment with that on your own.\n\n\n\n## Tuples\nTuple can rhyme with either "couple" or "drupal"; both pronunciations are correct. You\'ve seen tuples before when you wrote contracts that take in multiple arguments like `contract c(x, y, z) = { Nil }`. The number of items in a tuple is know as its arity. So the tuple received by contract `c` is arity three.\n\nTuples contain several pieces of data **in order**. They are always a fixed arity, and have relatively few methods. Thus they are the least interesting data structure, but at the same time, the most fundamental. Let\'s look at some of the methods offered by tuples.\n\n```javascript\nnew tCh, print(`rho:io:stdout`) in {\n\n  tCh!!((3, 4, 5))|\n\n  // Test nth\n  for (@t <- tCh){\n    print!(["Test nth. Expected: 5. Got ", t.nth(2)])\n  }\n  |\n\n  // Test toByteArray\n  for (@t <- tCh){\n    print!(["toByteArray test. Got: ", t.toByteArray()])\n  }\n}\n```\n\nWhat is the arity of [3, 4, 9, Nil]?\n- [ ] 3\n- [x] 4\n- [ ] 9\n- [ ] Nil\n\nWhat would `("a", "b", "c").nth(3)` evaluate to?\n- [ ] 3\n- [x] That\'s an error\n- [ ] "c"\n- [ ] ("a", "b", "c")\n\n### Exercise\nWrite a program that takes in a 4-tuple and prints elements 0 and 3 to the screen.\n\n\n## Lists\nLists are a lot like tuples, but they are made with square brackets instead of parentheses. They also have more methods, and can be concatenated or glued together using the `++` operator just like strings can. Here are examples of all of list\'s methods.\n\n```javascript\nnew lCh, stdout(`rho:io:stdout`) in {\n\n  // Make a new list, l\n  lCh!!([3, 4, 5])|\n\n  // Test nth\n  for (@l <- lCh){\n    stdout!("Test nth. Expected: 5. Got: ${ans}" %% {"ans": l.nth(2)})\n  }\n  |\n\n  // Test toByteArray\n  for (@l <- lCh){\n    stdout!(["Test toByteArray. Got: ", l.toByteArray()])\n  }\n  |\n\n  // Test slice\n  for (@l <- lCh){\n    stdout!(["Test slice. Expected: [4, 5]. Got: ", l.slice(1, 3)])\n  }\n  |\n\n  // Test length\n  for (@l <- lCh){\n    stdout!("Test length. Expected: 3. Got: \'${ans}" %% {"ans": l.length()})\n  }\n}\n```\n\n### Exercise\nImplement the body of the following running log contract. The user will call the contract every time they go for a run passing in the distance that they ran. The contract will keep track of all the runs in a list. You may also write methods to get all the run data, or get the total distance the user has run.\n\n```javascript\nnew logRun, runsCh in {\n\n  // No runs to start with\n  runsCh!([])|\n\n  contract logRun(distance) = {\n    // Your code here\n  }\n}\n```\n\n## Sets\n\nSets are similar to lists in some ways, but the one big difference is that sets **are not ordered**. A set is a collection of processes, but there is no first or last item in the set. There are also **no duplicates** allowed in sets. Let\'s take a look at some of set\'s methods.\n\n```javascript\nnew sCh, stdout(`rho:io:stdout`) in {\n\n  sCh!!(Set(3, 4, 5))|\n\n  // Test toByteArray\n  for (@s <- sCh){\n    stdout!(["Test toByteArray. Got: ", s.toByteArray()])\n  }\n  |\n\n  // Test Add\n  for (@s <- sCh){\n    stdout!(["Test add. Expected Set(3, 4, 5, 6), Got: ", s.add(6)])\n  }\n  |\n\n  // Test Diff\n  for (@s <- sCh){\n    stdout!(["Test diff. Expected: Set(5) Got: ", s.diff(Set(3, 4))])\n  }\n  |\n\n  // Test Union\n  for (@s <- sCh){\n    stdout!(["Test union. Expected: Set(1, 2, 3, 4, 5). Got: ", s.union(Set(1, 2))])\n  }\n  |\n\n  // Test Delete\n  for (@s <- sCh){\n    stdout!(["Test delete. Expected: Set(3, 4). Got: ", s.delete(5)])\n  }\n  |\n\n  // Test Contains\n  for (@s <- sCh){\n    stdout!(["Test contains. Expected: true. Got:", s.contains(5)])|\n    stdout!(["Test contains. Expected: false. Got: ", s.contains(6)])\n  }\n  |\n\n  // Test Size\n  for (@s <- sCh){\n    stdout!("Test size. Expected 3. Got: ${ans}" %% {"ans": s.size()})\n  }\n}\n```\n\nWhich code would produce a set of all club members who have not paid their dues?\n- [x] `allMembers.diff(paidMembers)`\n- [ ] `paidMembers.diff(allMembers)`\n- [ ] `paidMembers.union(allMembers)`\n- [ ] `paidMembers.contains(allMembers)`\n\nWhat is the result of `Set(1,2,3) == Set(3,2,1)`\n- [x] `true`\n- [ ] `false`\n- [ ] invalid syntax\n- [ ] `Set(2)`\n\n## Maps\nMaps are a lot like sets but they contain **key value pairs**. Maps are also unordered, but when you add an item (which is now known as a key) you also add an associated value. Here are examples of all of map\'s methods.\n\n```javascript\nnew mCh, print(`rho:io:stdout`) in {\n\n  mCh!!({"a": 3, "b": 4, "c": 5})|\n\n  // Test toByteArray\n  for (@m <- mCh){\n    print!(["Test toByteArray. Got: ", m.toByteArray()])\n  }\n  |\n\n  // Test Union\n  for (@m <- mCh){\n    print!(["Test union. Expected: {a: 3, b: 4, c: 5, d: 6}. Got: ", m.union({"d": 6})])\n  }\n  |\n\n  // Test Diff\n  for (@m <- mCh){\n    print!(["Test diff. Expected: {b: 4, c: 5}. Got: ", m.diff({"a": 3})])\n  }\n  |\n\n  // Test Delete\n  for (@m <- mCh){\n    print!(["Test delete. Expected: {a: 3, b: 4}. Got: ", m.delete("c")])\n  }\n  |\n\n  // Test Contains\n  for (@m <- mCh){\n    print!(["Test contains. Expected: true. Got: ", m.contains("c")])|\n    print!(["Test contains. Expected: false. Got: ", m.contains("d")])\n  }\n  |\n\n  // Test Get\n  for (@m <- mCh){\n    print!(["Test get. Expected: 4. Got: ", m.get("b")])\n  }\n  |\n\n  // Test GetOrElse\n  for (@m <- mCh){\n    print!(["getOrElseSuccessful. Expected: 4. Got: ", m.getOrElse("b", "?")])|\n    print!(["getOrElseFailed. Expected: ?. Got: ", m.getOrElse("d", "?")])\n  }\n  |\n\n  // Test Set\n  for (@m <- mCh){\n    print!(["Test set. Expected {a: 3, b: 2, c: 5}. Got: ", m.set("b", 2)])\n  }\n  |\n\n  // Test Keys\n  for (@m <- mCh){\n    print!(["Test keys. Expected Set(a, b, c)). Got: ", m.keys()])\n  }\n  |\n\n  // Test Size\n  for (@m <- mCh){\n    print!(["Test size. Expected 3. Got: ", m.size()])\n  }\n}\n```\n\nWhat is the result of `{"years": 1, "weeks": 52, "days": 365}.get(52)`\n- [ ] weeks\n- [ ] years\n- [ ] 52\n- [x] Nil\n\nTo demonstrate the usefulness of maps in rholang, let\'s consider this contract that looks up the capital of any country (that I bothered to type).\n\n```javascript\nnew capitalOf, print(`rho:io:stdout`) in {\n  new mapCh in {\n\n    // Use a persistent send instead of peeking later\n    mapCh!!({"Canada": "Ottawa",\n             "Nigeria": "Abuja",\n             "Germany": "Berlin",\n             "Antarctica": Nil,\n             "China": "Beijing",\n             "Ecuador": "Quito",\n             "Australia": "Canberra"})\n    |\n    contract capitalOf(@country, return) = {\n      for (@map <- mapCh) {\n        return!(map.getOrElse(country, "I don\'t know"))\n      }\n    }\n  }\n  |\n  new answerCh in {\n    capitalOf!("Canada", *answerCh)|\n    for (@cap <- answerCh) {\n      print!("Capital of ${cntry} is ${cap}." %% {"cntry": "Canada", "cap": cap})\n    }\n  }\n}\n```\n\n## Exercise\nStarting from the example code above, make a Countries and Capitals quiz game where the user calls up a contract and get\'s back a challenge country as well as an answer channel. The user then sends her best guess for that country\'s capital back over the answer channel and gets back a boolean for whether she was correct.\n\nTo learn how to use this game interactively with a nice user interface, check out some dapp development examples such as the [nth caller game](https://github.com/JoshOrndorff/nth-caller-game)\n\n## Exercise\nMap\'s `diff` method takes another map as an argument. What happens if the diff map has some of the same keys but with different values associated. For example:\n```\n{"a": "A", "b": "B", "c": "C"}.diff({"a": 25})\n```\n\n\n## Method Summary Table\n\nThat was a lot of info about data structures in one go. So here is a handy table to remind you what methods exist. This info is also on the [cheat sheet](./cheat-sheet).\n\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Tuple</th>\n<th>List</th>\n<th>Map</th>\n<th>Set</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>nth</td>\n<td>x</td>\n<td>x</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>toByteArray</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>union</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>diff</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>add</td>\n<td></td>\n<td></td>\n<td></td>\n<td>x</td>\n</tr>\n<tr>\n<td>delete</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>contains</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>get</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td></td>\n</tr>\n<tr>\n<td>getOrElse</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td></td>\n</tr>\n<tr>\n<td>set</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td></td>\n</tr>\n<tr>\n<td>keys</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td></td>\n</tr>\n<tr>\n<td>size</td>\n<td></td>\n<td></td>\n<td>x</td>\n<td>x</td>\n</tr>\n<tr>\n<td>length</td>\n<td></td>\n<td>x</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>slice</td>\n<td></td>\n<td>x</td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n\n## Sending and Receiving on Compound Names\nWe\'ve learned about several interesting data structures in this lesson. Data structures are processes just like integers, booleans, and `Nil`. So they can be quoted and turned into names like all those other processes. We can build contracts on those names just like we can any other names. Names that are built on data structures such as tuples are often called compound names.\n\nIn this example, Alice and Bob each have one unforgeable name (that I\'ve called key). The keys may be useful on their own (for things not shown in the snippet), but only when used together, can the contract shown be called. This is known as "rights amplification".\n\n```javascript\nnew alice, bob, key1, key2, stdout(`rho:io:stdout`) in {\n\n  alice!(*key1)|\n  bob!(*key2)|\n\n  contract @(*key1, *key2)(_) = {\n    stdout!("Congratulations, Alice and Bob, you\'ve cooperated.")\n  }\n}\n```\n\n\n\nWhat tuple is used to build the compound name in `contract @(*self, "getVal")(_) = { Nil }`?\n- [ ] `self`\n- [ ] `"getval"`\n- [x] `(*self, "getVal")`\n- [ ] `@(*self, "getVal")`\n- [ ] `@"getVal"`\n'}}]);