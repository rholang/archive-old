(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[47],{988:function(e,t,n){"use strict";n.r(t);t["default"]={content:'# A Tutorial for Matching in Rholang\n\n## Patterns we are allowed to match\n\nLet\'s clarify the implications of the following sentence from the Rholang tutorial: "There are two kinds of values in Rholang, names and processes. Patterns are names or processes with free variables, which appear to the left of an arrow in a `for` or after the `match` keyword."\n\nThe first is that a program cannot have any globally free variables. It also can\'t have any logical connectives, wildcards, or expressions using list or set remainders unless they form part of a pattern. For example, the following code snippets are not valid programs, despite the fact that they are valid components of patterns:\n\n* `@Nil!(Nil) /\\ @Nil!(Nil)` (logical connective)\n* `for( x <- @"channel" ){ _ }` (wildcard)\n* `[1 , 2 ... x]` (list remainder)\n\nThe second, in the same vein, is that a process variable does *not* match with anything that is not a process, meaning that it cannot match with a statement that contains a free variable, logical connectives, wildcards, or expressions using list or set remainders, unless those are written in a pattern fully contained in the statement.  Likewise, a name variable cannot match with anything that is not a quoted process, in the sense that it cannot contain free variables, logical connectives, etc unless they are correctly written in a pattern fully contained in the quoted process. For example, the following code\n\n    match {for( x <- @Nil ){ Nil }} {\n          {for( x <-   y  ){ Nil }} => { y!(Nil) }\n    }\n\n*will* match, resulting in `@Nil!(Nil)`, but\n\n    match {for( x <-  @{for( x <- @Nil ){ x!(Nil) }} ){ Nil }} {\n          {for( x <-  @{for( x <- @Nil ){    y    }} ){ Nil }} => { y }\n    }\n\nwill not match since `y` cannot match with `x!(Nil)`, and thus will evaluate to the empty process. Also,\n\n    for( x <- @{z!(Nil)} ){ Nil }\n\nwon\'t compile, due to the globally free variable `z`,\n\n    for( _ <- @{Nil} ){ {Nil} \\/ {@Nil!(Nil)} }\n\nis incorrect, due to a logical connective being where a process should be, and\n\n    for( x <- @{[1, 2 ... z]}){ Nil }\n\nwon\'t compile because `z` is free and thus the given list is a pattern.\n\n## Name Equivalence\n\nThe RHO calculus, on which Rholang is based, says that two names are equivalent when the processes that they quote are equivalent, and that processes are equated via the relations below (and nothing more). Here, `P`, `Q` and `R` are processes:\n\n* `P | Q` = `Q | P` (commutativity)\n* `P` = `P | Nil` = `Nil | P` (identity)\n* `(P | Q) | R` = `P | (Q | R)` (associativity)\n\nTherefore, `@{P | Q}` = `@{Q | P}` and `@{P | Nil}` = `@P` = `@{Nil | P}`, etc.\n\nIn Rholang, these relations only apply *to the top level* of any name. In addition to the three given above, we also evaluate expressions on the top level. So for example, as channels,\n\n* `@{10 + 2}` = `@{5 + 7}` and\n* `@{for(x <- @Nil){ 10 + 2 }}` = `@{for(x <- @Nil){ 5 + 7 }}`.\n\nSince we use variables, channels also respect alpha equivalence, meaning that, for example, as channels\n\n* `@{for( x <- @Nil ){ Nil }}` = `@{for( z <- @Nil ){ Nil }}`.\n\nIn the RHO calculus we don\'t have to worry about distinguishing the top level from other parts of a channel, but because of things like pattern-matching, we have to in Rholang. This will be relevant later on, where there are restrictions on pattern-matching because of this.\n\n## "Looking through the looking glass": Patterns Within Patterns\n\nPatterns follow the same rules as channels in terms of equivalence. In the case of -arity matching, joins, logical connectives, etc. the rules apply to each name pattern individually.\n\nHere we need to treat statements that are not on the top level. We reemphasize that the rules for name equivalences described in the last section only apply on the top level. When we are matching *patterns within patterns*, these equivalence rules do not apply and we check for an exact text match after normalizing, **excluding** alpha equivalence. The principle is that you can only look through the looking glass once: when checking name equivalence or matching a pattern to a name or a process, if a given pattern is part of a larger pattern, there has to be an exact match.\n\nFurthermore, we can\'t bind variables to parts of patterns. For example, the following send/receive will not match:\n\n    for( @{for( @{x!(y)} <- @Nil ){ Nil }} <- @Nil ){ Nil }  |\n    @Nil!( for( @{x!(9)} <- @Nil ){ Nil } )\n\nNaively, one might expect these to match, binding `y` to `9`, but to match with the above receive, one must send something alpha equivalent to:\n\n    @Nil!( for( @{x!(y)} <- @Nil ){ Nil } )\n\n## Precedence Rules\nWhen writing more complicated patterns, one should be aware of precedence rules of the operators in Rholang. Take for example the following pattern:\n\n    @{@x!(Nil) | y!(Nil)}\n\nA priori, it is unclear whether this should be interpreted as `@{{@x!(Nil)} | {y!(Nil)}}`, where `x` is a process variable and `y` is a name variable, or as `@{@{x!(Nil) | y}!(Nil)}`, where `x` is a name variable and `y` is a process variable. The chosen interpretation is vital, since the way we use `x` and `y` in the body depend on the type (process or name) of each of these terms. If the first interpretation is correct,\n\n    for( @{@x!(Nil) | y!(Nil)} <- @10 ){ @x!("success") | y!("success") }\n\nwill compile, while\n\n    for( @{@x!(Nil) | y!(Nil)} <- @10 ){ x!("success") | @y!("success") }\n\nwill not. If the second interpretation is correct, the opposite is true.\n\nIn Rholang, `@` binds tighter than `|`. Thus our first interpretation, `@{{@x!(Nil)} | {y!(Nil)}}`, is correct. We also have precedence rules for logical operations. Take for example the pattern\n\n    x /\\ @y!(Nil) \\/ @z!(10)\n\nLike in the example above, we could either interpret this as `{x /\\ @y!(Nil)} \\/ @z!(10)`, or as `x /\\ {@y!(Nil) \\/ @z!(10)}`. In Rholang, `/\\` takes precedence over `\\/` (as is the standard for logical connectives), so the first interpretation is correct.\n\n## Illegal Moves\nThere are some illegal moves that we ought to cover. The first has to do with arithmetic operations which, if you recall from the section on name equivalence, are evaluated on the top level, but not anywhere else. Because of this, in Rholang we cannot match parts of arithmetic operations. For example, we might expect\n\n    for( @{x + 7} <- @Nil ){ Nil }\n\nto match with a send such as `@Nil!(5 + 7)`, binding `x` to `5`. However, when messages are sent, top-level expressions are evaluated before sending, so this send will not match with anything&mdash;although it will compile!\n\nRemember, however, that an arithmetic operation that is in a pattern within a pattern is not evaluated when sent over a channel, and must be matched exactly. For example,\n\n    @Nil!(for( @{5 + 7} <- @Nil ){ Nil })\n\ncan only match with something that preserves the `5 + 7` intact. This means that to match with this we need something of the form\n\n    for(\n      @{for( @{5 + 7} <- ... ){ ... }}   <-   @Nil )\n      { ... }\n    )\n\nIf we wanted to bind a variable to the `5`, for example, we would need something of the form\n\n    for(\n      @{for( @{x + 7} <- ... ){ ... }}   <-   @Nil )\n      { ... }\n    )\n\nwhich would never match because patterns within patterns must match exactly.\n\nHowever, when the arithmetic operation is both (1) not on the top level of a pattern, and (2) not part of a pattern within a pattern, we *can* bind to parts of an arithmetic expression. For example, the receive\n\n    for( @{for( x <- @{5 + w}){Nil}} <- @Nil ){ @Nil!(w) }\n\ncan take a message from a send of the form\n\n    @Nil!( for( x <- @{5 + 7}){Nil} )\n\nevaluating to `@Nil!(7)`.\n\nThe other illegal move we ought to cover has to do with the `match` process. Remember that we cannot bind a free variable to any process or name containing free variables, or containing any out-of-context uses of logical connectives, joins, etc. In particular, it is syntactically incorrect to write:\n\n    match {match {@Nil!(Nil)} { x => {@Nil!(x)} }}\n      {\n          {match {@Nil!(Nil)} { y }} => { y }\n      }\n\nsince, if it did match, `y` would match to `x => {@Nil!(x)}`, which is neither a process nor a name.\n\n## Patterns With Parallel Processes\nWhen using parallel processes in patterns, it is sometimes not immediately obvious how a pattern will match. Take for example the following receive:\n\n    for( @{x | y} <- @Nil ){ Nil }\n\nGiven a send of the form `@Nil!( 10 | 20 )`, we might expect the receive to bind `x` to `10` and `y` to `20`. However, this match is not so straightforward. Since `x | y = y | x`, we just as well could match `x` to `20` and `y` to `10`. Futhermore, since `10 | 20 = 10 | 20 | Nil = Nil | 10 | 20`, the match could take place in a number of ways.\n\nThis send/receive will nondeterministically either bind `x` to `10`, `x` to `10 | 20` or `x` to the empty process `Nil` while `y` binds to whatever `x` does not take, binding to `Nil` if `x` binds to `10 | 20`. This nondeterminism applies to wildcards, too. As the interpreter stands, Rholang will choose one of `x` and `y`, give it `10 | 20`, and bind the other variable to `Nil`. Regardless, it is incorrect to write a program with such a pattern that relies on any of the variables matching to a specific piece of a message.\n\nNote further that since `P = P | Nil` for any process `P`, the pattern `@{x | y}` can match with a process with no parallel components. Likewise, `@Nil!(10 | 20)` would send successfully to something of the form `for( @{x | y | z} <- @Nil ){ Nil }`, where we\'ve added an extra variable on the receiving pattern.\n\nNote that we can write patterns with parallel processes that are not just process variables, such as `@{ @Nil!(x) | for( z <- c ){ z!(Nil) } }`, etc.\n\n## Logical Connectives\n\nLogical connectives can be incorporated into patterns, but we cannot send over a channel which contains logical connectives. For example, it is incorrect to write\n\n    @{ {10} \\/ {20} }!(Nil)\n\nWe can, however, correctly write\n\n    for( @{@{ {10} \\/ {20} }!(z)} <- @Nil ){ @Nil!(z) }\n\nwhich listens on `@Nil` for a process which sends either to `@10` or to `@20`. Whatever is being sent is grabbed and sent over `@Nil` in the body. If we use `/\\` in a pattern, any free variables which are in the pattern will be bound to their corresponding parts. However, if we use `\\/`, none of the variables in the parse tree below the node are bound. In particular, if `P1 \\/ P2` is in a pattern, the program will fail to run if any free variables in `P1` or `P2` appear in the body, since they cannot be guaranteed to bind to anything.\n\nWe note here that in Rholang only processes can be logically connected.\n\n## Wildcards vs Variables\nThere is an important, somewhat subtle difference between wildcards and variables in Rholang. A wildcard can be placed anywhere that a *free* variable can be placed, meaning that wildcards can be part of patterns but cannot be part of processes. For example, we cannot write\n\n    for( _ <- @Nil){ _!(Nil) }\n\ndue to the wildcard being in the body of the listen, even though it is correct to write\n\n    for( x <- @Nil){ x!(Nil) }\n\n(becuase the `x` is bound in the body of the receive). It is, however, perfectly acceptable to write\n\n    for( _ <- @Nil){ Nil }\n\nThat is the first distinction. The second distinction is that wildcards can bind to statements containing free variables, while variables cannot. For example, the pattern\n\n    new x in { p }\n\nwill match to *strictly fewer* patterns than the pattern\n\n    new x in { _ }\n\n`new x in { p }` will only match to a process which does not ever use the new channel in the body, such as `new x in { Nil }`. Here, `p` binds to `Nil`. It cannot match to something like `new x in { x!(Nil) }`, because `p` would have to match with `x!(Nil)`, which by itself has the free variable `x`. On the other hand, `new x in { _ }` will match with `new x in { x!(Nil) }`, throwing away `x!(Nil)`. Since `_` doesn\'t actually bind to anything, we are allowed to give it things with free variables. We note here that the rules for patterns within patterns still apply, meaning that a wildcard cannot be used to match to a piece of a pattern, unless that pattern itself uses a wildcard in precisely the same way.\n\n##Aditional Docs\n[clarification on pattern matching](https://developer.rchain.coop/assets/illegal%20moves.pdf)\n',data:{},isEmpty:false,excerpt:""}}}]);