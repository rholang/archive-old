(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[34],{994:function(e,n){e.exports="---\ntitle: Iteration\ndescription: Everything you need to know to get up and running with Atlaskit\n---\n# Iteration\nIn the code below, we show an example of iterating through a list.\n\n```javascript{numberLines: true}\n  new iterate in {\n    contract iterate(@list, process, done) = {\n      match list {\n        [hd, ...tl] => {\n          new ack in {\n            process!(hd, *ack) |\n            for (_ <- ack) { iterate!(tl, *process, *done) }\n          }\n        }\n        _ => done!(Nil)\n      }\n    } |\n    new process, done in {\n      iterate!([4,5,6], *process, *done) |\n      contract process(@item, ack) = {\n        /* handle processing of item */\n        ack!(Nil)\n      } |\n      for (_ <- done) {\n        /* done! */\n        Nil\n      }\n    }\n  }\n```\n3.) The `match` construction allows destructuring a variable through pattern matching.\n\n4.) List patterns support matching the remainder of a list.  If `list` matches the pattern of a head/tail pair then we execute the main body of the loop.\n\n5.) We create a channel for the item handler to notify us that it's done with the current item.\n\n6.) We invoke the processor on the item and the acknowledgement channel.\n\n7.) When we receive acknowledgement, we reinvoke the iterator on the tail.\n\n10.) If the list is empty, we signal that the processing is complete.\n\n14.) We invoke the iterator.\n\n15-18) This `contract` gets invoked for each item in the list.  On line 17, we tell the iterator that we're done with this item.\n\n19.) This `for` contains the code that should be executed when the interaction is complete.\n"}}]);