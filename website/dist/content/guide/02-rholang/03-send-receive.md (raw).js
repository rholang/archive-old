(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[30],{971:function(e,n){e.exports='---\ntitle: Sending and Receiving\ndescription: Everything you need to know to get up and running with Atlaskit\n---\n# Sending and Receiving\nSending and receiving is one of the most important things to understand in Rholang. \n\n>Note\n>\n>Because Rholang is an asynchronous programming langugage, there is no return in a function. That\'s why you call a function HelloWorld(args) via sending on the functions name HelloWorld. You are sending via the ! syntax.\n\n>Note\n>\n>Because of the asynchrony you don\'t know when the function you called via HelloWorld!(args) is sending the processed data back over some other channel, Rholang has the for(args<-channels) syntax for waiting until all the needed arguments are received over the channels.\n\n## Example\n```javascript{numberLines: true}\nnew HelloWorld, stdout(`rho:io:stdout`) in {\n  HelloWorld!("Hello, world!") |\n  for (@text <- HelloWorld) {\n    stdout!(text)\n  }\n}\n```\n1) This line declares a new name-valued variable `HelloWorld` and assigns to it a newly-created private name.  \n\n2) Every name is of the form `@P`, where `P` is a rholang process.  The `!` production takes a name `n` on its left and a process `P` on its right, then sends `@P` over the channel named `n`.  Lineforms the name `@"Hello, world"` and sends it on the channel whose name is stored in the variable `HelloWorld`.\n\n3) This `for` production creates a process that waits for a single message to be sent on the channel whose name is stored in the variable `HelloWorld`.  The pattern `@text` gets matched against the serialized process, binding the process-valued variable `text` to the original process that was sent.\n\n4) Rholang runtime environments may choose to include built-in processes listening on channels.  In this tutorial, we use new with the urn `rho:io:stdout` to request a channel where sent messages get printed to a console.\n\n>Note\n>\n>When you send data over a channel and there is no contract which is listening with for(args<-channels) for that channel, then these data is stored in the tuplespace (like a database), until some contract is starting to listening for it.\n\n### Name Equivalence\n\nIt is possible to write one single name in several different ways. For example, the two following channels are equivalent:\n```javascript\n@{10 + 2}\n@{5 + 7}\n```\nAny message sent over these channels can be received by listening on the channel `@12`. There are other instances in which a name can be written in two different ways. The guiding principle for this is that if `P` and `Q` are two equivalent processes, then `@P` and `@Q` are equivalent names. In particular, all of the following channels are equivalent:\n```javascript\n@{ P | Q }\n@{ Q | P }\n@{ Q | P | Nil }\n```\nBefore using a channel, Rholang first evaluates expressions and accounts for these `|` rules at the top level--but only at the top level. This means that if an arithmetic expression forms part of a pattern within a pattern, it is left untouched. Because of this,\n```javascript\nfor( @{ x + 5 } <- @"chan" ){ ... }\n```\nwill never receive any message on `@"chan"` since if we send anything, such as `10 + 5`, over `@"chan"`, the arithmetic expression gets evaluated and the name `@15` is sent.\n\nFinally, channels also respect a change in variable name (alpha equivalence), so the following channels are equivalent:\n```javascript\n@{ for( x <- chan ){ ... } }\n@{ for( z <- chan ){ ... } }\n```\n## Replicated receive\n```javascript{numberLines: true}\nnew HelloWorld, stdout(`rho:io:stdout`) in {\n  for (@text <= HelloWorld) {\n    stdout!(text)\n  } |\n  HelloWorld!("Hello, world!") |\n  HelloWorld!("Hola, mundo!")\n}\n```\n2.) Instead of handling only a single message, a `for` using a double arrow `<=` will persist, spawning a copy of the body for each message received.\n\n5-6) We send the string processes `"Hello, world!"` and `"Hola, mundo!"` on the channel `HelloWorld`.  It is non-deterministic which message will be processed first.\n\n## Contracts as sugar for replicated receive\n```javascript{numberLines: true}\nnew HelloWorld, stdout(`rho:io:stdout`) in {\n  contract HelloWorld(@text) = {\n    stdout!(text)\n  } |\n  HelloWorld!("Hello, world!") |\n  HelloWorld!("Hola, mundo!")\n}\n```\n2.) The only difference between this example and the last one is this line.  The `contract` production is syntactic sugar.  The process `contract Name(...formals) = { P }` means the same as `for (...formals <= Name) { P }`.\n\n## Replicated send\n```javascript{numberLines: true}\nnew HelloWorld, stdout(`rho:io:stdout`), stderr(`rho:io:stderr`) in {\n  HelloWorld!!("Hello, world!") |\n  for (@text <- HelloWorld) {\n    stdout!(text)\n  } |\n  for (@text <- HelloWorld) {\n    stderr!(text)\n  }\n}\n```\n2.) The double-bang `!!` means that this message will be sent again as soon as it is read.\n\n3-4, 6-7) There are two listening processes; each one consumes a single message from the channel and forwards it to either `"stdout"` or `"stderr"`.  The order in which they get forwarded to those channels is nondeterministic.\n\n## Sequential send\n\nIn order to have one message follow after another is known to have been received, we must use an acknowledgement message.\n```javascript{numberLines: true}\nnew chan, ack, stdoutAck(`rho:io:stdoutAck`) in {\n  chan!(0) |\n  for (_ <- ack) {\n    chan!(1)\n  } |\n  for (@num <= chan) {\n    stdoutAck(num, *ack)\n  }\n}\n```\n2) We send the message 0 on `chan`.\n3) We wait for a message on the channel `ack`, throw it away, and then proceed with the body.\n4) We send the messageon `chan`.\n6) We listen persistently for messages sent on `chan`.\n7) We forward each message to the channel `"stdoutAck"`, which expects both a value to print and a channel on which to send an acknowledgement message that the text has been received and printed.  In this program, we are guaranteed that 0 will be printed before 1.\n\n## Sending and receiving multiple processes\n```javascript{numberLines: true}\nnew chan, stdout(`rho:io:stdout`) in {\n  chan!(1,2,3) |\n  chan!((4,5,6)) |\n  chan!(7,8) |\n  chan!([9, 10], 11) |\n  chan!(12 | 13) |\n  for (@x, @y, @z <= chan) {\n    stdout!(["three", x, y, z])\n  } |\n  for (@a, @b <= chan) {\n    stdout!(["two", a, b])\n  } |\n  for (@a <= chan) {\n    stdout!(["one", a])\n  }\n}\n```\n2) We send three numeric processes on `chan`.  This send necessarily synchronizes with the `for` on line 7.\n3) We send one tuple process on `chan`.  This send necessarily synchronizes with the `for` on line 13.\n4) We send two numeric processes on `chan`.    This send necessarily synchronizes with the `for` on line 10.\n5) We send a list process and a numeric process on `chan`.    This send necessarily synchronizes with the `for` on line 10.\n6) We send a single process that is the par of two numeric expressions on `chan`.  This send necessarily synchronizes with the `for` on line 13.\n'}}]);