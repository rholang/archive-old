(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([[26],{967:function(e,n){e.exports='---\ntitle: Names and Processes\ndescription: Everything you need to know to get up and running with Atlaskit\n---\n# Names and Processes\nRholang has two kinds of values: processes and names.\n\n## Names \nA name represents a communication channel. You can send messages to a name or you can receive a message from a name.\n\nThe names are created with the construct\n```javascript\nnew someName in {\n//... code using someName\n}\n```\nIn the above example, the name `someName` is private. By "private", we mean that no other process can send or receive messages over this channel unless we explicitly send its name to the other process.  \n\nIf rholang is running on the blockchain, the messages sent on this channel will be publicly visible, so it is not "private" in the sense of being secret.  Channels created with `new` cannot be mentioned explicitly in rholang source code.  Even if you see the bits of a private name on the blockchain, there is no language production to turn those bits back into the name.  \n\nWe sometimes use the term "unforgeable" to describe these names when we want to emphasize the inability to construct them from bits.\n\nReceiving messages over a name is done using the `for` construction\n```javascript\nfor( x <- name1, y <- name2) {\n...\n}\n```\n\n## Processes\nIn Rholang everything is a process. Values like strings, booleans or numbers are also processes.\nThe processes can be aggregated using the operator \'|\'. Below are a few examples:\n```javascript\n1\ntrue\n1 + 1\nnew myName in {...}\nsomeName ! ("hello")\nfor( x <- someChannel) { ... }\np | q\n```\n### Primitive values\nRholang currently supports integers, strings, booleans, tuples, lists, sets and maps.\n'}}]);